# CSE 546 Matrix Project-3 Readme

Authors:
- Nishant Chaturvedi
- Vraj Rana
- Satya Pranay Manas Nunna

## Problem Statement

The objective of this project is to transfer an elastic application that automatically scales out and on-demand and is cost-effective from a public cloud environment to a hybrid cloud environment. This involves building the application using both Amazon Web Services (AWS) and OpenStack resources, with AWS as the primary cloud provider and OpenStack as the private cloud. The goal is to provide users with a meaningful cloud service while developing skills in cloud technologies and techniques for building future cloud-based applications.

## Design and Implementation

### 2.1 Architecture

The system architecture consists of a hybrid cloud environment comprising Amazon Web Services (AWS) and OpenStack resources. Users upload videos to an S3 input bucket stored in AWS. An application running in an OpenStack VM monitors this input bucket. When a new video is added to the input bucket, the application in the OpenStack VM triggers a Lambda function in AWS to process the video. The Lambda function uses ffmpeg to extract frames from the video, and the frames are stored in an S3 output bucket in AWS. The OpenStack VM also monitors the S3 output bucket to collect academic information generated by the Lambda function. This academic information can be displayed on the OpenStack VM's CLI or saved in a file on the VM. This architecture enables video processing in AWS while gathering academic information in the OpenStack VM environment.

### 2.2 Autoscaling

_(Description of the autoscaling components, configuration, and processes can be included here)_

## 3. Code and Installation

- Created a custom flavor on OpenStack with 1 GB RAM, 5 GB storage, and 2 VCPUs.
- Generated an instance with the base image of Ubuntu Focal Server.
- Associated a floating IP address and connected to the instance through SSH for code upload.
- Installed AWS CLI and boto3 for running the code, which triggers the Lambda function and provides the final output on the instance terminal.

#### Code Files

- **ProcessInput.py**: Monitors the SQS input queue and triggers the Lambda function when there's data. It calls **triggerLambda.py**.
- **triggerLambda.py**: Triggers the Lambda function after generating the payload, which, in turn, calls **handler.py** to generate the output.
- **readSQS.py**: Reads the SQS output queue and returns the output to the OpenStack instance while clearing the queue for new messages.
- **ProcessOutput.py**: Reads the output of the `readSQS` function, stores it in a CSV file, and prints the final result on the OpenStack instance.

## 4. Testing and Evaluation

Testing was conducted using the provided test cases from the workload generator. The following results are from running test case 1:

- Figure 4.1 shows the status of the terminal processing all the video files in the test directory.
- S3 input bucket: All files were uploaded to the input bucket. Figure 4.2 shows the status of the input bucket after the test.
- Figure 4.3 displays the OpenStack instance terminal output.

Test case 2 was executed to load test the application with 100 requests processed simultaneously. Figure 4.3 shows the output in the OpenStack instance terminal.

## 5. Individual Contributions

### 5.1 Nishant Chaturvedi (1222296088)

#### Design:

Participated in group discussions to decide on the project design, tasks, and task allocation. Responsible for implementing the code.

#### Implementation:

- Implemented code for monitoring the input S3 bucket and triggering the Lambda function created in project 2.
- Created an SQS queue and configured event notifications on the input bucket to create an entry in the queue when new data is added.
- Read the SQS queue for an element and triggered the Lambda function with video details.
- Developed code to listen to the output S3 bucket, generate output on the terminal, and handle SQS queues.
- Configured the Lambda function from the container image created in project 2.

#### Testing:

- Tested the Lambda function with sample data directly on the AWS console.
- Conducted separate testing of code for input and output buckets.
- Helped in integration testing with the team when setting up the OpenStack environment and running test cases.

### 5.2 Vraj Rana (1225420989)

#### Design:

Collaborated with team members to develop elastic applications in a hybrid cloud environment using AWS and OpenStack. Focused on setting up OpenStack on a virtual box.

#### Implementation:

- Installed and configured a virtual box on a local machine with Ubuntu.
- Configured the OpenStack public cloud on top of Ubuntu.
- Created S3 input and output buckets, SQS input and output queues, and a DynamoDB table.
- Programmed code to upload data into the DynamoDB table and query it.

#### Testing:

- Tested the code for loading data into DynamoDB and querying the table.
- Verified port forwarding setup and OpenStack configuration to launch instances.
- Combined code with the complete application and evaluated the output stored in the S3 output bucket.

### 5.3 Satya Pranay Manas Nunna (1225038204)

#### Design:

Participated in architecture and workload distribution discussions. Collaborated with the team and worked on OpenStack compute and networking setup with compute instances.

#### Implementation:

- Installed OpenStack and its dependencies.
- Uploaded the Ubuntu cloud server image to OpenStack.
- Created an OpenStack cloud instance, assigned a floating IP, and installed necessary dependencies.
- Configured the environment for running Python scripts, including installing boto3.
- Executed Python scripts to generate results.

#### Testing:

- Tested script outputs in the command line and validated the output for various inputs.
- Employed a workload generator script to test the application's execution time and validate the output against DynamoDB entries.